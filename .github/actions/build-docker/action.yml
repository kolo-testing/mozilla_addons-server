name: 'Build Docker Image'
description: 'Build docker image and optinally push to registry'
inputs:
    # Required Inputs
    registry:
      required: true
      description: docker registry to publish to
    image:
      required: true
      description: docker image to tag the image
    version:
      required: true
      description: docker image version to tag the image
    target:
      required: true
      description: docker image target to build to
    # Optional Inputs
    artifact_name:
      required: false
      description: optionally define the full artifact name
      default: ''
    username:
      required: false
      description: the username to login with
      default: ''
    password:
      required: false
      description: the password to login with
      default: ''
    push:
      required: false
      description: should the image be pushed to the defined registry
      default: 'false'
    cache_to:
      required: false
      description: Cache the docker image layers to a remote store
    cache_from:
      required: false
      description: Cache to pull before building the image

outputs:
  artifact_name:
    description: the artifact where the image was uploaded toJson
    value: ${{ steps.input_meta.outputs.artifact_name }}

runs:
  using: 'composite'
  steps:
    - id: input_meta
      shell: bash
      run: |
        artifact_name="${{ inputs.artifact_name }}"
        registry="${{ inputs.registry }}"
        image="${{ inputs.image }}"
        version="${{ inputs.version }}"
        target="${{ inputs.target }}"
        username="${{ inputs.username }}"
        password="${{ inputs.password }}"
        push="${{ inputs.push }}"
        cache_to="${{ inputs.cache_to }}"
        cache_from="${{ inputs.cache_from }}"

        echo "registry=$registry" >> $GITHUB_OUTPUT
        echo "image=$image" >> $GITHUB_OUTPUT
        echo "image_file=image.tar" >> $GITHUB_OUTPUT
        echo "version=$version" >> $GITHUB_OUTPUT
        echo "target=$target" >> $GITHUB_OUTPUT
        echo "cache_to=$cache_to" >> $GITHUB_OUTPUT
        echo "cache_from=$cache_from" >> $GITHUB_OUTPUT

        if [[ "$target" != 'development' && "$target" != 'production' ]]; then
          echo "invalid target $target. Expected `production` or `development`"
          exit 1
        else
          echo "target=$target" >> $GITHUB_OUTPUT
        fi


        if [[ "$push" == 'true' ]]; then
          if [[ "$username" == '' || "$password" == '' ]]; then
            echo "'push' set to true but missing username: $username and/or password: $password"
            exit 1
          fi
        fi
        echo "push=$push" >> $GITHUB_OUTPUT

        # Set default artifact name if empty
        if [[ "$artifact_name" == '' ]]; then
          artifact_name="build-docker-$target"
        fi
        echo "artifact_name=$artifact_name" >> $GITHUB_OUTPUT

        # URL for the github repository
        # TODO make sure this works for forks.
        git_repo_url="${{ github.server_url }}/${{ github.repository }}"

        echo "git_source_url=$git_repo_url.git#${{ github.ref }}" >> $GITHUB_OUTPUT
        echo "git_build_url=$git_repo_url/actions/runs/${{ github.run_id }}" >> $GITHUB_OUTPUT
        echo "git_sha=${{ github.sha }}" >> $GITHUB_OUTPUT

        cat $GITHUB_OUTPUT

    - name: Login
      id: login
      if: ${{ steps.input_meta.outputs.push == 'true' }}
      uses: docker/login-action@v3
      with:
        registry: ${{ steps.input_meta.outputs.registry }}
        # Read username and password directly from inputs as they are likely secrets
        # and cannot be passed around between step outputs
        username: ${{ inputs.username }}
        password: ${{ inputs.password }}

    - name: Docker meta
      id: docker_meta
      uses: docker/metadata-action@v5
      with:
        tags: |
            # use raw tag to allow the calling workflow to define the version of the image
            # and to prevent multiple tags from being associated with a build
            # TODO remove suffix when we enable the build in production
            type=raw,value=${{ steps.input_meta.outputs.version }},suffix=-next

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v1
      with:
        version: latest
        buildkitd-flags: --debug

    - name: Local Environment Setup
      shell: bash
      env:
        DOCKER_REGISTRY: ${{ steps.input_meta.outputs.registry }}
        DOCKER_IMAGE: ${{ steps.input_meta.outputs.image }}
        DOCKER_VERSION: ${{ steps.docker_meta.outputs.version }}
        DOCKER_COMMIT: ${{ steps.input_meta.outputs.git_sha }}
        VERSION_BUILD_URL: ${{ steps.input_meta.outputs.git_build_url }}
      run: |
        make setup

    - name: Build Docker Image
      id: build
      uses: docker/bake-action@v4
      env:
        IMAGE_TAR_FILE: ${{ steps.input_meta.outputs.image_file }}
        DOCKER_TARGET: ${{ steps.input_meta.outputs.target }}
      with:
        files: |
          ./docker-bake.hcl
          cwd://.env
          cwd://${{ steps.docker_meta.outputs.bake-file-labels }}
          cwd://${{ steps.docker_meta.outputs.bake-file-annotations }}
        # Let buildx checkout the code internally to guarnatee fresh build
        # This will ignore ANY changes to the local git repository code
        source: ${{ steps.input_meta.outputs.git_source_url }}
        # Push if logged in and specified to do so
        push: ${{ steps.login.outcome == 'success' && steps.input_meta.outputs.push == 'true' }}
        set: |
          *.cache-from=${{ steps.input_meta.outputs.cache_from }}
          *.cache-to=${{ steps.input_meta.outputs.cache_to }}


    - name: Upload Image Artifact
      uses: actions/upload-artifact@v4
      with:
        # We need to upload to a named artifact that is exposed to `run-docker`
        name: ${{ steps.input_meta.outputs.artifact_name }}
        # Upload just the single tar file
        path: ${{ steps.input_meta.outputs.image_file }}
        # We expect artifacts to be found, explicitly error if none are
        if-no-files-found: error
        # Artifacts should not last long, each run will create a new one
        retention-days: 1
        # Optimize for speed rather than size
        compression-level: 1
        # We should never create the exact same artifact twice in the same run
        overwrite: false

