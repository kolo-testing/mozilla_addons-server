####################################################################################################
# Our makefile makes use of docker compose commands. Our config files rely on environment variables
# both for passing configuration to the containers as well as configuring the compose file itself.
# Variables referenced in docker-compose*.yml should be read from .env, exported and saved in .env
####################################################################################################

DOCKER_PROGRESS ?= auto
DOCKER_METADATA_FILE ?= buildx-bake-metadata.json
DOCKER_PUSH ?=
export DEBUG ?= True
export DOCKER_COMMIT ?=
export DOCKER_BUILD ?=
export DOCKER_VERSION ?=
override DOCKER_MYSQLD_VOLUME = addons-server_data_mysqld
override DOCKER_COMPOSE_EXEC = docker compose exec
override DOCKER_COMPOSE_EXEC_WEB = $(DOCKER_COMPOSE_EXEC) --user olympia web

override BACKUPS_DIR = $(shell pwd)/backups
override EXPORT_DIR = $(BACKUPS_DIR)/$(shell date +%Y%m%d%H%M%S)
RESTORE_DIR ?= $(BACKUPS_DIR)/$(shell ls -1 backups | sort -r | head -n 1)

INITIALIZE_ARGS ?=
INIT_FORCE_DB ?=
INIT_SKIP_SEED ?=
INIT_SKIP_INDEX ?=

ifneq ($(INIT_FORCE_DB),)
	INITIALIZE_ARGS += --force-db
endif

ifneq ($(INIT_SKIP_SEED),)
	INITIALIZE_ARGS += --skip-seed
endif

ifneq ($(INIT_SKIP_INDEX),)
	INITIALIZE_ARGS += --skip-index
endif

DOCKER_BAKE_ARGS := \
	--file docker-bake.hcl \
	--file .env \
	--progress $(DOCKER_PROGRESS) \
	--metadata-file $(DOCKER_METADATA_FILE) \

ifeq ($(DOCKER_PUSH), true)
	DOCKER_BAKE_ARGS += --push
endif

DOCKER_COMPOSE_ARGS := \
	-d \
	--wait \
	--remove-orphans \
	--quiet-pull \

# Paths should be cleaned before mounting .:/data/olympia
# These are files which should be sourced from the container
# or should be fresh on every run of the project
CLEAN_PATHS := \
	src/olympia.egg-info \
	supervisord.pid \
	version.json \
	logs \
	buildx-bake-metadata.json \
	deps \

.PHONY: help_redirect
help_redirect:
	@$(MAKE) help --no-print-directory

.PHONY: help_submake
help_submake:
	@echo "Host only commands:"
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' Makefile-os | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
	@echo "\nAll other commands will be passed through to the docker 'web' container make:"
	@make -f Makefile-docker help_submake

.PHONY: setup
setup: ## create configuration files version.json and .env required to run this project
	for path in $(CLEAN_PATHS); do rm -rf "$(PWD)/$$path" && echo "$$path removed"; done
	./scripts/setup.py

.PHONY: push_locales
push_locales: ## extracts and merges translation strings
	bash ./scripts/push_l10n_extraction.sh $(ARGS)

.PHONY: update_docker
update_docker: data_export up data_restore ## update all the docker images

.PHONY: shell
shell: ## connect to a running addons-server docker shell
	$(DOCKER_COMPOSE_EXEC_WEB) bash

.PHONY: rootshell
rootshell: ## connect to a running addons-server docker shell with root user
	$(DOCKER_COMPOSE_EXEC) --user root web bash

.PHONY: data_export
data_export:
	@ mkdir -p $(EXPORT_DIR)

	# Extracting mysql database
	$(DOCKER_COMPOSE_EXEC) mysqld /usr/bin/mysqldump olympia > $(EXPORT_DIR)/data_mysqld.sql

.PHONY: data_restore
data_restore:
	@[ -d $(RESTORE_DIR) ] || (echo "Directory $(RESTORE_DIR) does not exist" && exit 1)

	# Wait for MySQL server to be ready
	$(DOCKER_COMPOSE_EXEC) mysqld bash \
	-c 'while ! mysqladmin ping --silent; do echo "waiting"; sleep 1; done'

	# Restoring mysql database
	$(DOCKER_COMPOSE_EXEC) -T mysqld /usr/bin/mysql olympia < $(RESTORE_DIR)/data_mysqld.sql

	$(MAKE) reindex_data

.PHONY: docker_compose_config
docker_compose_config: ## Show the docker compose configuration
	@docker compose config web --format json

.PHONY: docker_build_web
docker_build_web: ## Build the docker images using buildx bake
	docker buildx bake $(DOCKER_BAKE_ARGS) $(ARGS)

.PHONY: docker_pull_web
docker_pull_web: ## Pull the latest docker image using current tag
	docker compose pull web --policy always

.PHONY: docker_pull_or_build ## Pull or build the docker image based on the image version
docker_pull_or_build:
# If the image is tagged with version "local" then we should build the image before running
# docker compose up. The image will be available to docker compose, skipping a pull attempt.
# This is useful for local development where the image is built and tagged with "local".
# Also for CI/CID pipelines on forks where we cannot pull the image and must build locally.
# If the image is tagged with a version other than "local" then we should skip the build
# and let docker compose pull the image instead. This is useful for CI/CD pipelines where
# the image is already built and pushed to a registry.
	@IMAGE=$$(docker compose config web --format json | jq -r '.services.web.image'); \
	echo "image: $$IMAGE"; \
	if echo "$$IMAGE" | grep -q ":local"; then \
		$(MAKE) docker_build_web; \
	else \
		$(MAKE) docker_pull_web; \
	fi

.PHONY: docker_mysqld_volume_create
docker_mysqld_volume_create: ## Create the mysqld volume
	docker volume create $(DOCKER_MYSQLD_VOLUME)

.PHONY: docker_mysqld_volume_remove
docker_mysqld_volume_remove: ## Remove the mysqld volume
	docker volume rm $(DOCKER_MYSQLD_VOLUME)

.PHONY: docker_compose_down
docker_compose_down: ## Stop the docker containers
	docker compose down --rmi local --remove-orphans --volumes

.PHONY: docker_clean_volumes
docker_clean_volumes: ## Remove dangling volumes
	docker volume prune --force

.PHONY: docker_clean_images
docker_clean_images: ## Remove dangling images, preserving layer cache
	docker image prune --filter "dangling=true" --filter "label!=buildx.cache" --force

.PHONY: docker_clean_build_cache
docker_clean_build_cache: ## Remove buildx build cache
	docker buildx prune -af

.PHONY: clean_deps
clean_deps: ## Remove all files in the ./deps directory
	rm -rf ./deps/**

.PHONY: clean_docker
clean_docker: docker_compose_down docker_mysqld_volume_remove docker_clean_images docker_clean_volumes docker_clean_build_cache clean_deps ## Remove all docker resources taking space on the host machine

.PHONY: docker_compose_up
docker_compose_up: docker_mysqld_volume_create ## Start the docker containers
	docker compose up $(DOCKER_SERVICES) $(DOCKER_COMPOSE_ARGS) $(ARGS)

.PHONY: up
up: setup docker_pull_or_build docker_compose_up docker_clean_images docker_clean_volumes ## Create and start docker compose
	# Explicitly run initialize via the web container as make can get confused
	# both routing the command to the web container and
	# routing the command to the proper target.
	$(DOCKER_COMPOSE_EXEC_WEB) make -f Makefile-docker initialize_data ARGS=$(shell echo "'$(INITIALIZE_ARGS)'")

.PHONY: down
down: docker_compose_down docker_clean_images docker_clean_volumes ## Stop the docker containers and clean up non-peristent dangling resources

%: ## This directs any other recipe (command) to the web container's make.
	$(DOCKER_COMPOSE_EXEC_WEB) make $(MAKECMDGOALS) ARGS=$(ARGS)

# You probably want to put new commands in Makefile-docker, unless they operate
# on multiple containers or are host-os specific.
